What happens when you initialize a repository? Why do you need to do it?

How is the staging area different from the working directory and the repository?
What value do you think it offers?

How can you use the staging area to make sure you have one commit per logical
change?
After modifying the most recent file, use git status to which file have been modified, and that changes are not staged yet. Use git diff to see the exact change you've introduced since committing. The repository contains serval commits, and each commit contains several files. The staging area is copy of the most recent commit until I ad chagnes to it, so it has those same files with the most recent commit. Finally, the working directory also has the same files in it, but I've made some updates to game.js* . 

Use git diff commitid1 commitid2 to compare two commits

Use git diff                        with no arguments compare working directoty with staging area, this will show ang changes you made that you haven't added to the staging area yet. 
Use git add game.js Then add the current edited file to staging area
Use git diff to see the file in staged area is updated

Use git diff --staged to double check that the files I've added are really what I want to put in the commit. 

Use git commit -m "commit message" if this is what I want to commit.  

Use git reset --hard, which discards any changes in either the working directory or the staging area. 


What are some situations when branches would be helpful in keeping your history
organized? How would branches help?
Making a straight line of changes makes a lot of sence if you are fixing bugs, adding new features or updating documentation. But what if you wanted to try out a new experimental feature that you're still not sure will work, but you still want to have a working demo just show yor friends when they ask what you're working on? or maybe you are larning italian, and want to make a version of your project for italian speaking people while leaving the native language version intact. In this case, you would probably creating a setting for swithching between the two languages. 
Git allows you to create labels for your commits.These labels are called branches. In this case, we would have three different branches. 
First, master. master is the name given to main branch in most Git repositories and every time you create a repository, Git creates a master branch for you. 
Second branch would probably called italian. 
Third branch would probaly called exp (experimental feature)
When you checked out some old commits, you'd get the detached head message? Bassically, at that point, Git was warning you that you were looking at a commit that was not labelled with a branch name. 
So far, you've always been in a detached head state or on the master branch, which Git creates for you. 
It is possible to checkout a branch in the same way you checked out commits in the past, except with the hopefully human-readable branch name rather than an unpronounceable series of characters. If you check out a branch, and then make a commit, the branch label automatically updates to the new commit. That branch also stays checked out, so you do not have to check it out again.
As a matter of termilonogy, we sometimes refer to the current last commit on a branch being the tip of that branch. It ispossible to have multiple labels attachd to a single commit, but making a new commit will only update the branch that you have checked out and leave the others alone. 
The process of combing two branches is known as merging. And we'll get to that later on in the lesson. 


How do the diagrams help you visualize the branch structure?

What is the result of merging two branches together? Why do we represent it in
the diagram the way we do?

What are the pros and cons of Gitâ€™s automatic merging vs. always doing merges
manually?
